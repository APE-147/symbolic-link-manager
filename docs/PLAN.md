# PLAN

> 每次运行在文件底部追加一个 Cycle（6–8 个问题 + 选项效果 + 进度）。

## Cycle 1 — 2025-10-18

Progress
- 来自 TASKS 顶层复选框：9/9（100%）
- 计算依据：所有任务均已完成（含文档与示例更新）

Decision Questions（以 Questionary 交互为核心）
1) 扫描范围来源？
   - 选项：固定为「/Users/username/Developer/Data」；CLI 参数传入；从配置文件读取（如 `~/.config/slm.yml`）。
   - 影响：固定路径实现最快但不灵活；CLI 最灵活；配置文件便于复用与团队共享。
默认固定为「/Users/username/Developer/Data」；同时接收 CLI 参数传入

2) 如何发现“被指向”的文件夹？
   - 选项：仅检查 Home 目录内符号链接；检查一组可配置根目录；全盘扫描（排除系统路径）。
   - 影响：Home 范围速度快、覆盖有限；可配置根目录在速度与覆盖间折中；全盘扫描最全但最慢、权限风险高。
仅检查 Home 目录内符号链接

3) 多级菜单交互流程？
   - 选项：
     A. 先选“被指向的目标文件夹”→ 再选“哪些符号链接指向它”→ 输入新目标路径；
     B. 先选“符号链接来源”→ 显示其当前目标及所在 Data 子目录→ 输入新目标路径。
   - 影响：A 符合“围绕 Data 目录整理”的心智；B 便于逐个源链接处理。默认 A。
使用默认方案A, 但是需要注意“哪些符号链接指向它”仅展示, 不选择, 输入新目标迁移地址之后, 自动批量修改

4) 迁移语义与原链接处理？
   - 选项：移动目录并原地更新符号链接指向新路径；复制后切换符号链接、成功再删除旧目录；仅验证不改动（dry-run）。
   - 影响：移动最快但跨卷可能失败；复制更安全但耗时；dry-run 用于预检查和演示。
复制后切换符号链接、成功再删除旧目录

5) 目标存在/冲突策略？
   - 选项：禁止覆盖（失败即停）；允许合并（同名文件冲突失败）；启用自动备份为 `dest~TIMESTAMP` 后再移动。
   - 影响：禁止覆盖最安全但可能需要手动清理；合并易出错；备份可回滚但占用空间。
允许合并（同名文件冲突失败）启用自动备份为 `dest~TIMESTAMP` 后再移动

6) 原子性与跨卷移动实现？
   - 选项：优先 `os.rename`，跨卷回退到 `rsync --archive` 或 `shutil.copytree`+校验+删除；
     使用临时目录与最终换名实现“近似原子”。
   - 影响：保证一致性与可恢复性，提高实现复杂度。
不考虑夸卷

7) 校验与回滚策略？
   - 选项：迁移前后对比文件树摘要（数量/大小/哈希可选）；写入操作日志（JSON）；提供一键回滚脚本。
   - 影响：提高可审计性与安全性，成本是更多 I/O 与实现时间。
迁移前后对比文件树摘要（数量/大小/哈希可选）

8) 权限与忽略清单？
   - 选项：需要 sudo 时显式失败并给出建议；支持忽略模式（如 `node_modules`, `.venv`, `.*`）；
     仅处理目录型符号链接（默认）。
   - 影响：降低误操作风险，减少噪音，保证可重复性。
需要 sudo 时显式失败并给出建议, 不需要忽略模式, 仅处理目录型符号链接

建议默认值
- 扫描范围：可配置根目录，默认 `~` 与常用工作根（含 `/Users/username/Developer`）。
- 交互流程：方案 A（以 Data 目录为中心）。
- 迁移：先 dry-run，确认后执行"移动+更新符号链接+验证"，跨卷自动回退复制策略。
- 冲突：启用自动备份后再移动；全程记录 JSON 日志与回滚指令。

---

## Cycle 2 — 2025-10-18 (路径解析修复)

Progress
- 来自 TASKS 顶层复选框：9/9（100%） + 1 个修复任务已完成
- 计算依据：所有原有任务完成 + 相对路径解析修复已完成并测试通过

Decision Questions（针对相对路径解析问题）
1) 相对路径应相对于什么解析？
   - 选项 A：相对于当前工作目录（cwd）— 现有行为，导致用户错误
   - 选项 B：相对于 data_root — 符合用户预期，便于在 Data 目录内重组
   - 选项 C：提示用户必须使用绝对路径 — 最安全但体验差
   - 影响：
     * A: 保持现状，用户需要理解实现细节
     * B: 直觉化，减少输入，提高体验，需要额外逻辑
     * C: 无歧义但增加用户负担
   - **已选择 B**：相对路径相对于 data_root 解析

2) 如何处理不存在的父目录？
   - 选项 A：报错并中止 — 现有行为，导致 FileNotFoundError
   - 选项 B：自动创建父目录（mkdir -p） — 便捷且符合预期
   - 选项 C：询问用户是否创建 — 安全但增加交互步骤
   - 影响：
     * A: 需要用户手动创建目录
     * B: 自动化，减少步骤，可能创建意外目录
     * C: 安全但中断流程
   - **已选择 B**：自动创建父目录

3) 如何保持向后兼容？
   - 选项 A：绝对路径行为不变，仅优化相对路径 — 最小变更
   - 选项 B：统一所有路径处理逻辑 — 可能破坏现有用法
   - 影响：
     * A: 安全，不影响现有用户
     * B: 清理代码但风险高
   - **已选择 A**：仅改进相对路径，绝对路径保持不变

实施结果
- 修改：migrate_target_and_update_links() 添加 data_root 参数与智能解析
- 修改：_safe_move_dir() 自动创建父目录
- 测试：新增 2 个测试用例，全部 6 个测试通过
- 文档：README.md 添加路径解析规则；USAGE_EXAMPLE.md 添加示例
- 验收：用户输入 `dev/new` 正确解析为 `~/Developer/Data/dev/new`

---

## Cycle 3 — 2025-10-18 (设置 lk 默认配置并移除 slm 命令)  (@source: REQUIRES.md + 内置模板)

Progress: 100.00% (from TASKS.md, 计算依据: 9/9 顶层任务已完成)

Decision Questions（针对默认配置设置与命令简化）

Q1. 默认配置应该硬编码在代码中还是使用配置文件？
- A) 硬编码到 cli.py 的 argparse 默认值中
  - 效果：
    * 范围：仅修改 1 个文件（cli.py）
    * 风险：低，用户无需额外配置文件
    * 质量：简单直接
    * 复杂度：最低
    * 工期：最短（<10 分钟）
    * 成本：无额外依赖
    * 可维护性：集中在代码中，修改需要重新安装
    * 可观测性：通过 `--help` 可见默认值
- B) 创建系统级配置文件（如 /etc/slm/defaults.conf）
  - 效果：
    * 范围：需要处理系统级路径和权限
    * 风险：中，可能需要 sudo 权限
    * 质量：专业但过度设计
    * 复杂度：高
    * 工期：长（>30 分钟）
    * 成本：需要安装脚本
    * 可维护性：配置和代码分离
    * 可观测性：需要文档说明配置文件位置
- C) 保持现有 ~/.config/slm.yml 机制，文档说明推荐配置
  - 效果：
    * 范围：无代码修改，仅文档更新
    * 风险：低，但需要用户手动创建配置
    * 质量：依赖用户行为
    * 复杂度：无
    * 工期：短（<5 分钟）
    * 成本：无
    * 可维护性：配置灵活
    * 可观测性：需要用户主动查看配置文件

**建议：选择 A** - 硬编码默认值到 argparse，最简单直接，符合用户"无需参数即可运行"的需求

Q2. 是否保留 slm 命令以向后兼容？
- A) 完全移除 slm 命令，仅保留 lk
  - 效果：
    * 范围：修改 pyproject.toml 的 1 行
    * 风险：低（本项目用户主要是作者本人）
    * 质量：简化维护
    * 复杂度：最低
    * 工期：瞬时（<1 分钟）
    * 成本：无
    * 可维护性：减少入口点，降低混淆
    * 可观测性：清晰的单一命令
- B) 保留 slm，输出废弃警告并重定向到 lk
  - 效果：
    * 范围：需要修改 cli.py 添加废弃逻辑
    * 风险：低
    * 质量：更友好的迁移体验
    * 复杂度：中
    * 工期：短（~15 分钟）
    * 成本：额外代码逻辑
    * 可维护性：临时代码，将来需要清理
    * 可观测性：通过警告信息引导用户
- C) 同时保留两个命令，行为完全一致
  - 效果：
    * 范围：保持现状
    * 风险：无
    * 质量：无改进
    * 复杂度：无
    * 工期：无
    * 成本：无
    * 可维护性：维护两个入口点
    * 可观测性：可能造成用户困惑

**建议：选择 A** - 按用户需求完全移除 slm

Q3. 默认值设置的粒度？
- A) 仅设置 data-root 和 scan-roots 默认值
  - 效果：
    * 范围：修改 argparse 的 2 个参数
    * 风险：低
    * 质量：最小变更原则
    * 复杂度：低
    * 工期：短（<5 分钟）
    * 成本：无
    * 可维护性：清晰的变更范围
    * 可观测性：`--help` 显示明确
- B) 同时设置所有常用参数默认值（包括 dry-run, log-json）
  - 效果：
    * 范围：修改多个参数
    * 风险：中，可能改变用户预期行为
    * 质量：全面但可能过度
    * 复杂度：中
    * 工期：中（~15 分钟）
    * 成本：更多测试用例
    * 可维护性：需要维护更多默认值
    * 可观测性：可能降低参数灵活性
- C) 设置配置优先级：硬编码 < 配置文件 < CLI 参数
  - 效果：
    * 范围：需要重构配置加载逻辑
    * 风险：高，可能引入回归
    * 质量：架构最优
    * 复杂度：高
    * 工期：长（>30 分钟）
    * 成本：重构风险
    * 可维护性：长期优秀，短期复杂
    * 可观测性：需要详细文档

**建议：选择 A** - 仅修改必要的两个参数，保持简单

Q4. 如何处理相对路径与绝对路径展开？
- A) 使用 Path.home() / "Developer" / "Data" 形式
  - 效果：
    * 范围：跨平台兼容（macOS/Linux）
    * 风险：低
    * 质量：标准 Python 实践
    * 复杂度：低
    * 工期：瞬时
    * 成本：无
    * 可维护性：优秀，可读性高
    * 可观测性：`--help` 显示展开后的路径
- B) 使用字符串 "~/Developer/Data"，依赖后续 expanduser()
  - 效果：
    * 范围：代码简洁
    * 风险：低，现有代码已处理 expanduser
    * 质量：简洁
    * 复杂度：最低
    * 工期：瞬时
    * 成本：无
    * 可维护性：依赖后续处理
    * 可观测性：`--help` 显示 ~ 形式（更友好）
- C) 直接硬编码绝对路径 "/Users/username/Developer/Data"
  - 效果：
    * 范围：失去可移植性
    * 风险：高，其他用户无法使用
    * 质量：差
    * 复杂度：最低
    * 工期：瞬时
    * 成本：限制使用范围
    * 可维护性：差
    * 可观测性：明确但不灵活

**建议：选择 B** - 使用 ~ 形式，保持简洁且友好

Q5. argparse prog 参数是否需要更新？
- A) 将 prog="slm" 改为 prog="lk"
  - 效果：
    * 范围：修改 1 行
    * 风险：无
    * 质量：与命令名称一致
    * 复杂度：瞬时
    * 工期：瞬时
    * 成本：无
    * 可维护性：保持一致性
    * 可观测性：`--help` 显示正确命令名
- B) 保持 prog="slm" 不变
  - 效果：
    * 范围：无修改
    * 风险：低，但帮助信息会不一致
    * 质量：次优
    * 复杂度：无
    * 工期：无
    * 成本：用户困惑
    * 可维护性：留下技术债
    * 可观测性：混淆

**建议：选择 A** - 更新 prog 参数以保持一致性

Q6. 测试策略？
- A) 新增测试用例验证默认参数值
  - 效果：
    * 范围：新增 1-2 个测试函数
    * 风险：低
    * 质量：确保默认值正确
    * 复杂度：低
    * 工期：短（~10 分钟）
    * 成本：轻量测试
    * 可维护性：防止回归
    * 可观测性：测试作为文档
- B) 手动测试即可
  - 效果：
    * 范围：无代码修改
    * 风险：中，未来可能回归
    * 质量：不可重复
    * 复杂度：无
    * 工期：短（~5 分钟）
    * 成本：无
    * 可维护性：差
    * 可观测性：无自动化证据
- C) 集成测试验证完整流程
  - 效果：
    * 范围：需要 mock questionary 交互
    * 风险：低
    * 质量：最全面
    * 复杂度：高
    * 工期：长（>20 分钟）
    * 成本：维护复杂测试
    * 可维护性：长期优秀
    * 可观测性：最强

**建议：选择 A** - 轻量单元测试，足以覆盖默认值变更

Q7. 文档更新范围？
- A) 仅更新 README.md 和 USAGE_EXAMPLE.md
  - 效果：
    * 范围：修改 2 个文件
    * 风险：低
    * 质量：足够
    * 复杂度：低
    * 工期：短（~10 分钟）
    * 成本：无
    * 可维护性：标准实践
    * 可观测性：用户可见
- B) 同时更新 AGENTS.md 和 docs/ 下所有文档
  - 效果：
    * 范围：修改 5+ 个文件
    * 风险：低
    * 质量：全面
    * 复杂度：中
    * 工期：中（~20 分钟）
    * 成本：更多工作量
    * 可维护性：完整记录
    * 可观测性：项目状态清晰
- C) 不更新文档，等到下次大版本
  - 效果：
    * 范围：无
    * 风险：高，用户困惑
    * 质量：差
    * 复杂度：无
    * 工期：无
    * 成本：用户体验损失
    * 可维护性：差
    * 可观测性：无

**建议：选择 B** - 全面更新文档，符合 codex-feature agent 规范

建议与权衡（本轮建议）：
- 建议：Q1->A（硬编码默认值）, Q2->A（移除 slm）, Q3->A（仅必要参数）, Q4->B（使用 ~ 形式）, Q5->A（更新 prog）, Q6->A（轻量测试）, Q7->B（全面文档）
- 理由：
  1. 最小变更原则：仅修改必要的参数，降低风险
  2. 符合用户需求：直接实现"无需参数运行 lk"
  3. 保持灵活性：CLI 参数和配置文件仍可覆盖
  4. 可测试性：添加单元测试保证正确性
  5. 可维护性：清晰的文档和代码一致性
  6. 符合规范：遵循 codex-feature agent 的文档更新要求
